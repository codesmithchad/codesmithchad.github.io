---
layout: post
title: Test Driven Development Tutorial for iOS&colon; Getting Started from raywenderlich.com
subtitle: raywenderlich.com을 참고하여 TDD 입문을 해보았다.
# cover-img: /assets/img/toastMessageView.png
# thumbnail-img: /assets/img/thumb.png
# share-img: /assets/img/path.jpg
tags: [iOS, test, tdd, xctest, unit test]
---

> ref: [Test Driven Development Tutorial for iOS&colon; Getting Started](https://www.raywenderlich.com/5522-test-driven-development-tutorial-for-ios-getting-started\)

**테스트는`Red -> Green -> Refactoring` 사이클의 반복**\
아라비아 숫자를 로마 숫자로 변환 하는 기능을 TDD 방법론으로 구현한다.\
(첫 사이클은 테스트가 정상 동작하는지를 확인하는 과정부터 시작한다.)

&nbsp;

* 아래의 파일들을 추가한다.
    * `ConverterTests.swift`: 유닛 테스트
    * `Converter.swift`: 컨버터 기능 구현
    * `ViewController.swift`: 컨버터 샘플 구현

&nbsp;

## Creating a Unit Test Case Class

> import를 지정하여 대상 프로젝트를 테스트 있도록 한다.

    ```swift
    // ConverterTests
    import XCTest
    @testable import <project scheme name>
    ```
    
&nbsp;

## Writing Your First Test

`Red -> Green -> Refactoring` 사이클의 첫번째 순서다.\
가장 먼저 항상 실패하는 케이스를 만든다.\
failed case를 먼저 만들지 않으면 항상 success case가 발생하는 테스트를 작성한 경우 놓칠 수 있다.
 
* ConverterTests 코드 작성

    ```swift
    // ConverterTests
    func testConversionForOne() {
        let result = converter.convert(1)
        XCTAssertEqual(result, "I", "Conversion for 1 is incorrect")
    }
    ```

&nbsp;
 
* Converter 코드 작성

    ```swift
    // Converter
    func convert(_ number: Int) -> String {
        return ""
    }
    ```

&nbsp;
 
## Fixing Your First Failure

`Red -> Green -> Refactoring` 사이클의 두번째 순서다.\
항상 성공하는 케이스를 만든다.\
아직까지는 이 테스트 블락이 정상 동작하는지를 확인하는 과정이다.

```swift
// Converter
func convert(_ number: Int) -> String {
    return "I"
}
```

&nbsp;

---

&nbsp;

# Extending the Functionality

&nbsp;
 
## 1. Working on Test #2


    
    ```swift
    // ConverterTests
    func testConversionForTwo() {
        let result = converter.convert(2)
        XCTAssertEqual(result, "II", "Conversion for 2 is incorrect")
    }
    ```

* Converter의 convert 함수의 인자가 2가 되는 경우 실패한다

    ```swift
    // Converter
    func convert(_ number: Int) -> String {
        return String(repeating: "I", count: number)
    }   
    ```

* success를 얻기 위해 convert 함수를 수정한다.

&nbsp;

## 2. Working on Test #3

    ``` swift
    // ConverterTests
    func testConversionForFive() {
        let result = converter.convert(5)
        XCTAssertEqual(result, "V", "Conversion for 5 is incorrect")
    }
    ```

* #2까지의 진행으로 로마 숫자 4까지는 문제가 없다. (사실 4는 문제가 있지만 일단 넘어가자.)\
하지만 5부터는 다시 문제가 발생한다.

    ```swift
    // Converter
    func convert(_ number: Int) -> String {
        if number == 5 {
            return "V"
        } else {
            return String(repeating: "I", count: number)
        }
    }
    ```

* 우선 테스트가 통과할 수 있도록 가장 쉽고 빠른 대처를 한다.

&nbsp;
 
## 3. Working on Test #4

    ```swift
    // ConverterTests
    func testConversionForSix() {
        let result = converter.convert(6)
        XCTAssertEqual(result, "VI", "Conversion for 6 is incorrect")
    }
    ```

* 인자가 6이 되는 경우 다시 테스트를 통과하지 못한다.
 
    ```swift
    // Converter    
    func convert(_ number: Int) -> String {
        var result = "" // 1 로컬 변수를 result를 선언
        var localNumber = number // 2 number 인자를 localNumber로 카피
        if localNumber >= 5 { // 3 localNumber가 5 이상인 경우
            result += "V" // 4 로마숫자 V를 result에 추가
            localNumber = localNumber - 5 // 5 localNumber에서 5를 뺌
        }
        result += String(repeating: "I", count: localNumber) // 6 남은 숫자만큼 I를 반복
        return result
    }
    ```

* 테스트를 통과시키 위한 대처를 한다.

&nbsp;
 
## 4. Working on Test #5

    ```swift
    // ConverterTests
    func testConversionForTen() {
        let result = converter.convert(10)
        XCTAssertEqual(result, "X", "Conversion for 10 is incorrect")
    }
    ```

* 인자가 10이 되는 경우 다시 테스트를 통과하지 못한다.

    ```swift
    // Converter
    if localNumber >= 10 { // 1
        result += "X" // 2
        localNumber = localNumber - 10 // 3
    }
    ```

* 테스트를 통과시키기 위한 대처를 한다.\
Converter.swift의 `var localNumber = number` 아래에 10 이상인 경우의 대처를 추가한다.

&nbsp;
 
## 5. Uncovering a Pattern

    ```swift
    // ConverterTests
    func testConversionForTwenty() {
        let result = converter.convert(20)
        XCTAssertEqual(result, "XX", "Conversion for 20 is incorrect")
    }
    ```
 
* 인자가 20이 되는 경우 다시 테스트를 통과하지 못한다.
 
    ```swift
    // Converter
    // if localNumber >= 10 {
    while localNumber >= 10 {
    ```

* Converter 조건절을 반복절로 변경하여 대처한다.

&nbsp;
 
## 6. Handling the Special Cases

### 인자가 4인 예외



    ```swift
    // ConverterTests
    func testConversionForFour() {
        let result = converter.convert(4)
        XCTAssertEqual(result, "IV", "Conversion for 4 is incorrect")
    }
    ```
 
* 테스트 코드 작성

    **Converter.swift**
    ```swift
    if localNumber >= 4 {
        result += "IV"
        localNumber = localNumber - 4
    }
    ```

* 예외 케이스 처리
    * 10과 5인 경우의 처리가 끝난후 4에 대한 처리를 하도록 한다
 
### 인자가 9인 예외

    ```swift
    // ConverterTests
    func testConversionForNine() {
        let result = converter.convert(9)
        XCTAssertEqual(result, "IX", "Conversion for 9 is incorrect")
    }
    ```
 
* 테스트 코드 작성

    ```swift
    // Converter
    if localNumber >= 9 {
        result += "IX"
        localNumber = localNumber - 9
    }
    ```

* 에외 케이스 처리
    * 5와 10 사이에서 처리되어야 하므로 5와 10 사이에 추가한다.

&nbsp;

---

&nbsp;


# Refactoring


&nbsp;


## Optimizing Your Code

* 위의 과정에서 발견할 수 있는 패턴들을 정의하여 리팩토링

```swift
// Converter
func convert(_ number: Int) -> String {
    var localNumber = number
    var result = ""

    // 숫자와 그에 해당하는 로마 숫자를 담은 튜플 배열
    let numberSymbols: [(number: Int, symbol: String)] = [(10, "X"),
                                                          (9, "IX"),
                                                          (5, "V"),
                                                          (4, "IV"),
                                                          (1, "I")]
    // 튜플 배열을 돌리면서
    for item in numberSymbols {
        // 숫자 변환을 처리하기 위해 발견한 패턴을 통해 배열의 각 항목을 실행
        while localNumber >= item.number {
            result += item.symbol
            localNumber = localNumber - item.number
        }
    }
    return result
}
```

&nbsp;
 
## Handling Other Edge Cases

* 위의 테스트중 아직 테스트하지 않은 0의 경우를 테스트\
-> 실패하지 않는다

    ```swift
    // ConverterTests
    func testConverstionForZero() {
        let result = converter.convert(0)
        XCTAssertEqual(result, "", "Conversion for 0 is incorrect")
    }
    ```

&nbsp;

* 가능한 가장 큰 숫자인 3999\
-> 실패한다

    ```swift
    // ConverterTests
    func testConverstionFor3999() {
        let result = converter.convert(3999)
        XCTAssertEqual(result, "MMMCMXCIX", "Conversion for 3999 is incorrect")
    }
    ```

&nbsp;

* 이 엣지 케이스에 대한 정의가 없으므로 실패한다.\
엣지 케이스를 추가한다.

    ```swift
    // Converter
    let numberSymbols: [(number: Int, symbol: String)] = [(1000, "M"),
                                                          (900, "CM"),
                                                          (500, "D"),
                                                          (400, "CD"),
                                                          (100, "C"),
                                                          (90, "XC"),
                                                          (50, "L"),
                                                          (40, "XL"),
                                                          (10, "X"),
                                                          (9, "IX"),
                                                          (5, "V"),
                                                          (4, "IV"),
                                                          (1, "I")]
    ```

&nbsp;

---

&nbsp;


# Apply converter to example

```swift
// ViewController
final class ViewController: UIViewController {
    
    private let converter = Converter()
    private let textField = UITextField()

    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
    }

    private func setupUI() {
        title = "Converter"
        view.backgroundColor = .systemBackground
        let calcButton = UIButton()
        let resultLabel = UILabel()
        view.addSubviews(textField, calcButton, resultLabel)
        NSLayoutConstraint.activate([
            textField.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 50),
            textField.leftAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leftAnchor, constant: 16),
            textField.rightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.rightAnchor, constant: -16),
            textField.heightAnchor.constraint(equalToConstant: 50),
            
            calcButton.topAnchor.constraint(equalTo: textField.bottomAnchor, constant: 30),
            calcButton.leftAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leftAnchor, constant: 16),
            calcButton.rightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.rightAnchor, constant: -16),
            calcButton.heightAnchor.constraint(equalToConstant: 50),

            resultLabel.topAnchor.constraint(equalTo: calcButton.bottomAnchor, constant: 30),
            resultLabel.leftAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leftAnchor, constant: 16),
            resultLabel.bottomAnchor.constraint(lessThanOrEqualTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -16),
            resultLabel.rightAnchor.constraint(equalTo: view.safeAreaLayoutGuide.rightAnchor, constant: -16),
            resultLabel.heightAnchor.constraint(equalToConstant: 50)
        ])
        
        textField.placeholder = "enter arabic numbers"
        textField.keyboardType = .numberPad
        calcButton.setTitle("caculate", for: .normal)
        calcButton.addAction(UIAction(title: "caculate", handler: { [weak self] _ in
            guard let strongSelf = self,
                  let text = strongSelf.textField.text,
                  let int: Int = Int(text)else { return }
            let converted = strongSelf.converter.convert(int)
            resultLabel.text = converted
        }), for: .touchUpInside)
        resultLabel.textAlignment = .center
    }
}

extension UIView {
    func addSubviews(_ subviews: UIView...) {
        subviews.forEach({
            self.addSubview($0)
            $0.translatesAutoresizingMaskIntoConstraints = false
            $0.layer.borderWidth = 1
            $0.layer.borderColor = UIColor.red.cgColor
        })
    }
}
```

&nbsp;

---

&nbsp;