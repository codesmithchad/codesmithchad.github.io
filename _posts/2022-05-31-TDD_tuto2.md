---
layout: post
title: iOS Unit Testing and UI Testing Tutorial from raywenderlich.com PT.1
subtitle: raywenderlich.com을 참고하여 TDD 입문을 해보았다.
# cover-img: /assets/img/toastMessageView.png
# thumbnail-img: /assets/img/thumb.png
# share-img: /assets/img/path.jpg
tags: [iOS, test, tdd, xctest, unit test, ui test]
---

> https://www.raywenderlich.com/21020457-ios-unit-testing-and-ui-testing-tutorial\
이번에는 iOS Unit Testing and UI Testing Tutorial를 참고해 보았다.

이번에 배우게 될 내용
* 모델과 비동시 함수를 테스트 하는 방법
* 스텁과 mock object를 이용하여 라이브러리나 시스템 오브젝트를 가짜로 동작시켜 보기
* UI와 퍼포먼스 테스트
* 코드 커버리지 툴 사용법

&nbsp;

## 무엇을 테스트 할 것인가

테스트가 커버해야 할 것들
* Core functionality: 모델 클래스와 메소드가 컨트롤러와 상호작용
* 일반적인 UI workflows
* 상태 범위
* Bug fixes

&nbsp;

### Understanding Best Practices for Testing

* Fast: 테스트는 빠르게 실행되어야 한다.
* Independent/Isolated: 테스트는 상태가 공유되어서는 안된다. 독립적이어야 한다.
* Repeatable: 테스트는 항상 동일한 결과가 나와야 한다. 외부 데이터나 동시성 이슈는 간헐적인 테스트 실패를 발생시킬 수 있다.
* Self-validating: 테스트는 완전히 자동화 되어야 한다. 테스트 결과는 성공/실패 둘 중 하나여야 한다.
* Timely: 이론상 프로덕션 코드가 테스트 되기 전에 테스트를 작성하여야 한다.

&nbsp;

---

&nbsp;

## Unit Testing in Xcode

### Creating a Unit Test Target

* cmd+6을 눌러 테스트 pane을 연다.
* 좌하단의 + 버튼을 눌러 New Unit Test Target...을 눌러 스킴을 추가한다.
* XCTestCase를 상속하는 테스트 클래스가 작성된다. 
* 사용하지 않는 testPerformanceExample() 와 testExample() 는 제거한다.

### Using XCTAssert to Test Models

1. test 할 대상을 import 한다.
```swift
@testable import BullsEye
```

2. setUpWithError() 위에 BullsEyeGame 타입의 sut(system under test) 변수를 선언한다.
```swift
var sut: BullsEyeGame!
```

3. setUpWithError()에서 sut를 생성한다.
```swift
try super.setUpWithError()
sut = BullsEyeGame()
```

4. tearDownWithError() 에서 `다른 테스트에 영향이 가지 않도록` sut를 nil 처리한다. 
```swfit
sut = nil
try super.tearDownWithError()
```

&nbsp;

---

&nbsp;

## Writing Your First Test

```swift
func testScoreIsComputedWhenGuessIsHigherThanTarget() {
    // given
    let guess = sut.targetValue + 5
    
    // when
    sut.check(guess: guess)
    
    // then
    XCTAssertEqual(sut.scoreRound, 95, "Score computed from guess is wrong")
}
```

given, when, then 섹션으로 테스트 포맷 작성하는 것이 좋다.
1. Given: 필요한 값을 이 섹션에서 지정한다. 예를 들어 guess value를 만들면 targetValue와 얼마가 다른지 특정할 수 있다.
2. When: 테스트 대상이 되는 코드를 실행하는 섹션
3. Then: 실패하는 경우 메세지와 함께 나타내거나 기대하는 결과값이 나오는지를 확인하는 섹션

&nbsp;

### Debugging a Test

`BullsEyeGame` 에는 목적에 맞지 않는 버그가 있으면 그 것을 찾는 방법을 연습한다.\
오동작을 확인하기 위해 given 섹션에 있는 targetValue에서 뺴기 5를 하도록 하여 테스트를 만든다.

```swift
func testScoreIsComputedWhenGuessIsLowerThanTarget() {
    // given
    let guess = sut.targetValue - 5

    // when
    sut.check(guess: guess)

    // then
    XCTAssertEqual(sut.scoreRound, 95, "Score computed from guess is wrong")
}
```

guess와 targetValue의 차이는 여전히 5이며 스코어는 95가 나와야 한다.\
cmd + 8을 눌러 디버그 페인으로 변경하고 좌하단의 + 버튼을 눌러 Test Failure Breakpoint를 추가하자.\
테스트가 실패하는 곳에서 브레이크포인트가 동작할 것이다.

&nbsp;

테스트를 실행하면 XCTAssertEqual에서 테스트가 실패하고 브레이크 포인트가 걸리게 된다.\
디버그 콘솔에서 sut와 guess를 확인해 보자.
* guess는 targetValue - 5 인데 scoreRound는 95가 아닌 105이다.
원인을 찾기 위해 일반적인 디버깅 프로세스를 사용한다.\
check(guess:) 함수 내부의 dirrecence가 할당되는 곳에 일반 브레이크 포인트를 걸고 테스트를 실행한다.\
디버그 콘솔을 확인하니 difference가 -5 이다. 스코어가 100 - (-5) 로 계산된 것이다.\
이를 수정하기 위해 let `let difference = guess - targetValue` 를 `let difference = abs(targetValue - guess)` 로 수정한다.

&nbsp;

### Using XCTestExpectation to Test Asynchronous Operations

이제 어떻게 모델과 테스트 실패를 디버깅하는지 배웠다. 다음은 비동기 코드를 테스트하는 방법을 배워볼 차례다.
&nbsp;

BullsEyeGame은 다음 게임을 위한 랜덤 타겟 넘버를 얻기 위해 URLSession을 사용한다.\
URLSession method는 비동기이다. (URLSession은 응답을 주지만 실행이 끝날때까지 동작을 완료하지 않는다.)\
비동기 함수를 태스트하려면 비동기 명령이 완료될때까지 기다리는 XCTestExpectation를 사용해야 한다.\
비동기 테스트는 대체로 느리고 시간이 걸리므로 다른 빠른 유닛테스트와는 분리하는것이 좋다.\

&nbsp;

BullsEyeSlowTests 라는 이름으로 테스트 타겟을 추가하자. (cmd+6 > 좌하단 + 버튼 > New Unit Test Target)\
새로 만든 BullsEyeSlowTests를 열고 BullsEye app module을 import 하자.
```swift
@testable import BullsEye
```

&nbsp;

sut(system under test)를 선언하고 setup과 teardown에  생성 / 제거를 구현한다.

```swift
var sut: URLSession!

override func setUpWithError() throws {
    try super.setUpWithError()
    sut = URLSession(configuration: .default)
}

override func tearDownWithError() throws {
    sut = nil
    try super.tearDownWithError()
}
```

&nbsp;

다음으로 비동기 테스트를 추가한다.

```swift
// Asynchronous test: success fast, failure slow
func testValidApiCallGetsHTTPStatusCode200() throws {
    // given
    let urlString = "http://www.randomnumberapi.com/api/v1.0/random?min=0&max=100&count=1"
    let url = URL(string: urlString)!
    // 1
    let promise = expectation(description: "Status code: 200")
    
    // when
    let dataTask = sut.dataTask(with: url) { _, response, error in
        // then
        if let error = error {
            XCTFail("Error: \(error.localizedDescription)")
            return
        } else if let statusCode = (response as? HTTPURLResponse)?.statusCode {
            if statusCode == 200 {
                // 2
                promise.fulfill()
            } else {
                XCTFail("Status code: \(statusCode)")
            }
        }
    }
    
    dataTask.resume()
    // 3
    wait(for: [promise], timeout: 5)
}
```

1. expectation(description:):  리턴되는 XCTestExpectation를 promise에 저장한다. description에 기대하는 내용을 서술한다.
2. promise.fulfill():  비동기 함수 completion handler에서 성공시 클로저에서 호출되도록 한다.
3. wait(for:timeout:):  리퀘스트가 성공하거나 타임아웃이 나기 전까지 테스트가 실행을 유지하도록 한다.

&nbsp;

### Failing Fast

실패하는 경우를 확인하기 위해 유효하지 않은 url로 변경해 본다.

```swift
let url = URL(string: "http://www.randomnumberapi.com/test")!
```

테스트를 실행하면 실패하지만 timeout interval에 도달할때까지 시간이 걸린다.\
이것은 리퀘스트가 항상 성공할 것이고 promise.fulfill()가 불릴것으로 가정했기 때문이다.\
그로 인해 리퀘스트 실패시 타임아웃이 걸리지 않으면 종료가 되지 않는다.
&nbsp;

가정을 바꾸는 것으로 이것을 개선하고 테스트가 빠르게 실패하도록 할 수 있다.\
리퀘스트가 성공할 때까지 기다리는 대신 비동기 함수의 completion handler가 불릴때까지만 대기하도록 한다.\
이것이 서버로 부터 성공이든 에러든 가능한 한 빠른 응답을 받게 한다. 
&nbsp;

어떻게 동작하는지 확인하기 위해 새 테스트를 추가한다.\
그 전에 변경했던 유효하지 않은 url은 원복 시키고 아래의 테스트를 추가한다.

```swift
func testApiCallCompletes() throws {
    // given
    let urlString = "http://www.randomnumberapi.com/api/v1.0/random?min=0&max=100&count=1_invalid"
    let url = URL(string: urlString)!
    let promise = expectation(description: "Completion handler invoked")
    var statusCode: Int?
    var responseError: Error?
    
    // when
    let dataTask = sut.dataTask(with: url) { _, response, error in
        statusCode = (response as? HTTPURLResponse)?.statusCode
        responseError = error
        promise.fulfill()
    }
    dataTask.resume()
    wait(for: [promise], timeout: 5)
    
    // then
    XCTAssertNil(responseError)
    XCTAssertEqual(statusCode, 200)
}
```

&nbsp;

핵심 차이점은 기대를 충족하는 completion handler를 추가한 것이고 이는 몇초밖에 걸리지 않는다. 리퀘스트가 실패한다면 실패가 될 것이다.\
테스트를 실행하면 몇초만에 실패를 확인할 수 있다. 리퀘스트가 유효하지 않으므로 실패하게 된고 타임아웃 시간까지 지체하지 않는다.\
테스트가 성공하도록 url을 수정하고 다시 테스트를 실행하면 성공하는 것을 볼 수 있다.

### Failing Conditionally

경우에 따라 테스트는 이해할 수 없는 경우가 있다. 예를 들어 네트웍이 끊긴 상태에서 `testValidApiCallGetsHTTPStatusCode200()`를 실행하면 어떨까?\
물론 상태코드 200을 받을 수 없으니 테스트를 통과하지는 못한다.\
하지만 이것은 아무것도 테스트 하지 않아서 실패도 하지않는다.\
다행히도 애플이 precondition fail이 날 경우에 사용할 수 있는 XCTSkip을 소개했다.\
아래 코드를 sut 선언부 아래 추가하자.

```swift
let networkMonitor = NetworkMonitor.shared
```

NetworkMonitor는 네트웍 연결은 쉽게 확인할 수 있는 NWPathMonitor wrapping한 객체이다.\
`testValidApiCallGetsHTTPStatusCode200()` 에 `XCTSkipUnless`를 테스트 시작 부분에 추가하자.

```swift
try XCTSkipUnless(networkMonitor.isReachable, "Network connectivity needed for this test.")
```

`XCTSkipUnless(_:_:)`는 네트웍이 끊긴경우 테스트를 스킵한다. 네트웍을 중단하여 확인해 보자.\
라인 넘버 부분에 성공도 실패도 아닌 새로운 아이콘을 확인할 수 있다.\
네트웍을 연결하고 다시 테스트를 실행하면 성공하는 것을 확인할 수 있다.\
`testApiCallCompletes()`에도 같은 코드를 추가하자.

&nbsp;

---

&nbsp;


to be continued.. `Faking Objects and Interactions`