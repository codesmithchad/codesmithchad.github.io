---
layout: post
title: iOS Unit Testing and UI Testing Tutorial from raywenderlich.com PT.2
subtitle: raywenderlich.com을 참고하여 TDD를 학습해 본다.
# cover-img: /assets/img/toastMessageView.png
# thumbnail-img: /assets/img/thumb.png
# share-img: /assets/img/path.jpg
tags: [iOS, test, tdd, xctest, unit test, ui test]
---

## Faking Objects and Interactions

이제 `URLSession`을 통해 얻은 데이터도 정상 동작하는지 확인하고 싶다.\
대부분의 앱들이 컨트롤이 불가한 시스템이나 라이브러리 오브젝트와 상호작용한다.\
이것들과 상호작용하는 테스트는 느려지거나 반복적이지 않아 첫번째 원칙을 위반할 수 있다.\
대신 스텁이나 mock 오브젝트를 통해 가짜 인터렉션을 구성할 수 있다.\

시스템이 라이브러리 오브젝트에 의존성이 있다면 가짜를 사용하자.

### Faking Input From Stub
`getRandomNumber(completion:)`가 정확하게 다운로드한 데이터를 파싱하는지 확인하자.\
스텁 데이터로 가짜 `BullsEyeGame` 세션을 구성해 보자.\

테스트 페인으로 이동하여 +를 누르고 `New Unit Test Class`를 추가하고 `BullsEyeFakeTests`로 명명하고 `BullsEyeTests` 디렉토리에 저장하여 BullsEyeTests의 타겟으로 설정한다.\

마찬가지로 앱 모듈을 import 한다.

```swift
@testable import BullsEye
```

`BullsEyeFakeTests`애 `BullsEyeGame` 타입의 sut를 선언하고 setup과 teardown을 아래와 같이 설정한다.

```swift
var sut: BullsEyeGame!

override func setUpWithError() throws {
    try super.setUpWithError()
    sut = BullsEyeGame()
}

override func tearDownWithError() throws {
    sut = nil
    try super.tearDownWithError()
}
```

이 프로젝트의 서포팅 파일중에는 `URLSessionStub`을 포함하고 있다.\
`URLSessionProtocol`이라는 이름의 간단한 프로토콜이 data task를 만드는 메소드와 함께 정의되어 있다.\
또한 이 프로토콜을 따르는`URLSessionStub` 정의되어 있다.\
이니셜라이저가 데이터, reponse, 에러 데이터를 리턴하도록 정의되어 있다.\

이 fake를 설정하기 위해 `BullsEyeFakeTests`로 이동하여 아래의 테스트를 추가하자.

```swift
func testStartNewRoundUsesRandomValueFromApiRequest() {
    // given
    // 1
    let stubbedData = "[1]".data(using: .utf8)
    let urlString = "http://www.randomnumberapi.com/api/v1.0/random?min=0&max=100&count=1"
    let url = URL(string: urlString)!
    let stubbedResponse = HTTPURLResponse(url: url, statusCode: 200, httpVersion: nil, headerFields: nil)
    let urlSessionStub = URLSessionStub(data: stubbedData, response: stubbedResponse, error: nil)
    sut.urlSession = urlSessionStub
    let promise = expectation(description: "Value Received")
    
    // when
    sut.startNewRound {
        // then
        // 2
        XCTAssertEqual(self.sut.targetValue, 1)
        promise.fulfill()
    }
    wait(for: [promise], timeout: 5)
}
```

이 테스트는 두가지를 한다.
1. 가짜 데이터와 응답, 가짜 세션 오브젝트를 설정한고 가짜 세션을 sut에 에 주입한다.
2. 스텁이 가짜 비동기 메소드를 포함하고 있으므로 이번에도 비동기로 작성하여야 한다.\
startNewRound(completion:)를 호출하면 페이크 넘버와 targetValue가 비교하여 페이크 데이터를 맞게 파싱하는지 확인한다.


테스트를 실행하면 실제 네트웍이 아니기 때문에 빠르게 성공한다. 

### Faking an Update to Mock Object

앞의 테스트에서는 가짜 오브젝트를 넣기 위해 스텁을 사용하였다. 다음은 코드가 userDefaults에 제대로 업데이트 되는지 확인하기 위해 mock 오브젝트를 사용할 것이다.\
이 게임은 두가지 스타일이 있다. 유저는 다음 두가지를 할 수 있다.
1. 슬라이더를 움직여 타겟 값을 맞출 수 있다.
2. 슬라이더의 위치에 따라 타겟값을 추측할 수 있다.

우하단에 있는 세그먼트 컨트롤을 통해 게임 스타일을 변경하고 이것을 UserDefatuls에 저장한다.\
\
다음 테스트에서는 `gameStyle` 프로퍼티를 제대로 저장하는지 확인한다.\
\
`BullsEyeTests`를 타겟으로 하는 새 테스트 클래스 `BullsEyeMockTests`로 추가하자.

```swift
@testable import BullsEye

class MockUserDefaults: UserDefaults {
    var gameStyleChanged = 0
    override func set(_ value: Int, forKey defaultName: String) {
        if defaultName == "gameStyle" {
            gameStyleChanged += 1
        }
    }
}
```

`MockUserDefaults`는 `gameStyleChanged`를 증가시키기 위해 `set(_:forKey:)`를 오버라이드한다.\
비슷한 테스트는 Bool 변수로 설정하는 경우가 잦지만 Int 증감은 더 유연함을 줄 수 있다.\
이 테스트는 앱이 함수를 한번만 호출하는지를 확인할 것이다.\
\
다음으로 `BullsEyeMockTests`에 sut와 mock 오브젝트를 선언한다.
```swift
var sut: ViewController!
var mockUserDefaults: MockUserDefaults!
```

setUpWithError()와 tearDownWithError()를 아래와 같이 수정한다.
```swift
override func setUpWithError() throws {
    try super.setUpWithError()
    sut = UIStoryboard(name: "Main", bundle: nil)
        .instantiateInitialViewController() as? ViewController
    mockUserDefaults = MockUserDefaults(suiteName: "testing")
    sut.defaults = mockUserDefaults
}

override func tearDownWithError() throws {
    sut = nil
    mockUserDefaults = nil
    try super.tearDownWithError()
}
```

이것은 sut와 mock 오브젝트를 생성하고 mock 오브젝트를 sut에 주입한다.\
\
이제 템플릿에 있는 함수를 두 default 테스트로 수정한다.

```swift
func testGameStyleCanBeChanged() {
    // given
    let segmentedControl = UISegmentedControl()
    
    // when
    XCTAssertEqual(mockUserDefaults.gameStyleChanged, 0, "gameStyleChanged should be 0 before sendActions")
    segmentedControl.addTarget(sut, action: #selector(ViewController.chooseGameStyle(_:)), for: .valueChanged)
    segmentedControl.sendActions(for: .valueChanged)
    
    // then
    XCTAssertEqual(mockUserDefaults.gameStyleChanged, 1, "gameStyle user default wasn't changed")
}
```

assertion 타이밍은 테스트 메소드가 세그먼트 컨트롤을 변경하여 `gameStyleChanged` 플래그는 0이 될 떄이다.\
assetion은 true라면 `set(_:forKey:)`가 한번 호출될 것이다.\
테스트를 실행해보면 성공하는 것을 볼 수 있다.

&nbsp;

---

&nbsp;

## UI Testing in Xcode

UI 테스트는 유저 인터페이스의 상호작용을 테스트 할 수 있게 해준다.\
UI 테스트는 앱의 요청이 발생하는 UI 오브젝트를 해당 이벤트에 맞추 발생시키고 그 객체들에게 이벤트를 보낸다.\
그 api들은 UI 오브젝트의 속성들을 시험할 수 있게 해주고 그에 상응하는 상태를 비교할 수 있게 해준다.\
\
테스트 네비게이터에서 새 `UI Test Target`을 추가한다.\
타겟이 `BullsEye`인지 확인하고 `BullsEyeUITests`로 이름 짓는다.\
\
`BullsEyeUITests`를 열고 최상단에 아래의 변수를 추가한다.
```swift
var app: XCUIApplication!
```

`tearDownWithError()`을 제거하고 `setUpWithError()`에 아래의 내용을 추가한다.
```swift
try super.setUpWithError()
continueAfterFailure = false
app = XCUIApplication()
app.launch()
```

미리 생성되어 있던 두 함수를 제거하고 아래의 함수를 추가한다.
```swift
func testGameStyleSwitch() {    
}
```

`testGameStyleSwitch()`에 새 라인을 하나 추가하고 디버그콘솔페인에 있는 녹화 버튼을 누른다.\
이는 시뮬레이터를 녹화모드로 앱을 열게하고 인터렉션을 테스트 커맨드로 녹화한다.\
앱이 로드되면 게임 스타일 스위치에 있는 슬라이드 세그먼트와 상단 레이블을 탭하자.\
녹화 버튼을 다시 눌러 녹화를 중단하자.\

그렇게 하면 아래와 같은 3개의 라인이 생긴다.
```swift
let app = XCUIApplication()
app.buttons["Slide"].tap()
app.staticTexts["Get as close as you can to: "].tap()
```

레코더가 방금 녹화한 행위와 같은 행동을 취하는 코드를 작성한다.\
게임 스타일 새그먼트와 상단 레이블을 탭하는 요청을 날리게 된다.\
앞으로 UI 테스트를 작성하는데 이 방식을 사용하게 된다.\
혹시 다른 상태가 나타난다면 삭제하도록 하자.\
\
첫번째 라인은 setUpWithError()에 추가한 프로퍼티와 중복되므로 제거한다.\
아직은 어떤것도 탭을 할 필요가 없으므로 2번 3번 라인의 .tap()을 제거하자.\
이제 ["Slide"] 옆에 있는 작은 메뉴를 열고 `segmentedControls.buttons["Slide"]`를 선택하면 아래와 같은 코드가 될 것이다.\
Now, open the little menu next to ["Slide"] and select segmentedControls.buttons["Slide"].


```swift
app.segmentedControls.buttons["Slide"]
app.staticTexts["Get as close as you can to: "]
```

레코드 상태에서 다른 객체를 탭하는 것으로 테스트에서 접근가능한 객체를 찾는데 도움을 줄 것이다.\
이제 given 섹션을 만들기 위해 아래의 내용을 추가하자.

```swift
// given
let slideButton = app.segmentedControls.buttons["Slide"]
let typeButton = app.segmentedControls.buttons["Type"]
let slideLabel = app.staticTexts["Get as close as you can to: "]
let typeLabel = app.staticTexts["Guess where the slider is: "]
```

Now that you have names for the two buttons in the segmented control 
and the two possible top labels, add the following code below:
세그먼트 컨트롤에 있는 두 버튼과 상단 레이블들의 이름을 얻었으니 다음의 코드를 추가하자.

```swift
// given
let slideButton = app.segmentedControls.buttons["Slide"]
let typeButton = app.segmentedControls.buttons["Type"]
let slideLabel = app.staticTexts["Get as close as you can to: "]
let typeLabel = app.staticTexts["Guess where the slider is: "]

// then
if slideButton.isSelected {
    XCTAssertTrue(slideLabel.exists)
    XCTAssertFalse(typeLabel.exists)
    
    typeButton.tap()
    XCTAssertTrue(typeLabel.exists)
    XCTAssertFalse(slideLabel.exists)
} else if typeButton.isSelected {
    XCTAssertTrue(typeLabel.exists)
    XCTAssertFalse(slideLabel.exists)
    
    slideButton.tap()
    XCTAssertTrue(slideLabel.exists)
    XCTAssertFalse(typeLabel.exists)
}
```

이것은 세그먼트 컨틀롤러의 각 버튼을 누를 때마다 해당 레이블이 존재하는지를 체크하게 된다.\
테스트를 실행하면 모든 assertoin이 성공하는 것을 볼 수 있다.

&nbsp;

---

&nbsp;

## Testing Performance