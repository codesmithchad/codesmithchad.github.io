---
layout: post
title: iOS Unit Testing and UI Testing Tutorial from raywenderlich.com PT.2
subtitle: raywenderlich.com을 참고하여 TDD를 학습해 본다.
# cover-img: /assets/img/toastMessageView.png
# thumbnail-img: /assets/img/thumb.png
# share-img: /assets/img/path.jpg
tags: [iOS, test, tdd, xctest, unit test, ui test]
---

## Faking Objects and Interactions

이제 `URLSession`을 통해 얻은 데이터도 정상 동작하는지 확인하고 싶다.\
대부분의 앱들이 컨트롤이 불가한 시스템이나 라이브러리 오브젝트와 상호작용한다.\
이것들과 상호작용하는 테스트는 느려지거나 반복적이지 않아 첫번째 원칙을 위반할 수 있다.\
대신 스텁이나 mock 오브젝트를 통해 가짜 인터렉션을 구성할 수 있다.
\
시스템이 라이브러리 오브젝트에 의존성이 있다면 가짜를 사용하자.

### Faking Input From Stub
`getRandomNumber(completion:)`가 정확하게 다운로드한 데이터를 파싱하는지 확인하자.\
스텁 데이터로 가짜 `BullsEyeGame` 세션을 구성해 보자.
\

테스트 페인으로 이동하여 +를 누르고 `New Unit Test Class`를 추가하고 `BullsEyeFakeTests`로 명명하고 `BullsEyeTests` 디렉토리에 저장하여 BullsEyeTests의 타겟으로 설정한다.
\
마찬가지로 앱 모듈을 import 한다.

```swift
@testable import BullsEye
```

`BullsEyeFakeTests`애 `BullsEyeGame` 타입의 sut를 선언하고 setup과 teardown을 아래와 같이 설정한다.

```swift
var sut: BullsEyeGame!

override func setUpWithError() throws {
    try super.setUpWithError()
    sut = BullsEyeGame()
}

override func tearDownWithError() throws {
    sut = nil
    try super.tearDownWithError()
}
```

이 프로젝트의 서포팅 파일중에는 `URLSessionStub`을 포함하고 있다.\
`URLSessionProtocol`이라는 이름의 간단한 프로토콜이 data task를 만드는 메소드와 함께 정의되어 있다.\
또한 이 프로토콜을 따르는`URLSessionStub` 정의되어 있다.\
이니셜라이저가 데이터, reponse, 에러 데이터를 리턴하도록 정의되어 있다.
\

이 fake를 설정하기 위해 `BullsEyeFakeTests`로 이동하여 아래의 테스트를 추가하자.

```swift
func testStartNewRoundUsesRandomValueFromApiRequest() {
    // given
    // 1
    let stubbedData = "[1]".data(using: .utf8)
    let urlString = "http://www.randomnumberapi.com/api/v1.0/random?min=0&max=100&count=1"
    let url = URL(string: urlString)!
    let stubbedResponse = HTTPURLResponse(url: url, statusCode: 200, httpVersion: nil, headerFields: nil)
    let urlSessionStub = URLSessionStub(data: stubbedData, response: stubbedResponse, error: nil)
    sut.urlSession = urlSessionStub
    let promise = expectation(description: "Value Received")
    
    // when
    sut.startNewRound {
        // then
        // 2
        XCTAssertEqual(self.sut.targetValue, 1)
        promise.fulfill()
    }
    wait(for: [promise], timeout: 5)
}
```

이 테스트는 두가지를 한다.
1. 가짜 데이터와 응답, 가짜 세션 오브젝트를 설정한고 가짜 세션을 sut에 에 주입한다.
2. 스텁이 가짜 비동기 메소드를 포함하고 있으므로 이번에도 비동기로 작성하여야 한다.\
startNewRound(completion:)를 호출하면 페이크 넘버와 targetValue가 비교하여 페이크 데이터를 맞게 파싱하는지 확인한다.


테스트를 실행하면 실제 네트웍이 아니기 때문에 빠르게 성공한다. 

### Faking an Update to Mock Object

앞의 테스트에서는 가짜 오브젝트를 넣기 위해 스텁을 사용하였다. 다음은 코드가 userDefaults에 제대로 업데이트 되는지 확인하기 위해 mock 오브젝트를 사용할 것이다.\
이 게임은 두가지 스타일이 있다. 유저는 다음 두가지를 할 수 있다.
1. 슬라이더를 움직여 타겟 값을 맞출 수 있다.
2. 슬라이더의 위치에 따라 타겟값을 추측할 수 있다.

우하단에 있는 세그먼트 컨트롤을 통해 게임 스타일을 변경하고 이것을 UserDefatuls에 저장한다.\
\
다음 테스트에서는 `gameStyle` 프로퍼티를 제대로 저장하는지 확인한다.\
\
`BullsEyeTests`를 타겟으로 하는 새 테스트 클래스 `BullsEyeMockTests`로 추가하자.

```swift
@testable import BullsEye

class MockUserDefaults: UserDefaults {
    var gameStyleChanged = 0
    override func set(_ value: Int, forKey defaultName: String) {
        if defaultName == "gameStyle" {
            gameStyleChanged += 1
        }
    }
}
```

`MockUserDefaults`는 `gameStyleChanged`를 증가시키기 위해 `set(_:forKey:)`를 오버라이드한다.\
비슷한 테스트는 Bool 변수로 설정하는 경우가 잦지만 Int 증감은 더 유연함을 줄 수 있다.\
이 테스트는 앱이 함수를 한번만 호출하는지를 확인할 것이다.\
\
다음으로 `BullsEyeMockTests`에 sut와 mock 오브젝트를 선언한다.
```swift
var sut: ViewController!
var mockUserDefaults: MockUserDefaults!
```

setUpWithError()와 tearDownWithError()를 아래와 같이 수정한다.
```swift
override func setUpWithError() throws {
    try super.setUpWithError()
    sut = UIStoryboard(name: "Main", bundle: nil)
        .instantiateInitialViewController() as? ViewController
    mockUserDefaults = MockUserDefaults(suiteName: "testing")
    sut.defaults = mockUserDefaults
}

override func tearDownWithError() throws {
    sut = nil
    mockUserDefaults = nil
    try super.tearDownWithError()
}
```

이것은 sut와 mock 오브젝트를 생성하고 mock 오브젝트를 sut에 주입한다.\
\
이제 템플릿에 있는 함수를 두 default 테스트로 수정한다.

```swift
func testGameStyleCanBeChanged() {
    // given
    let segmentedControl = UISegmentedControl()
    
    // when
    XCTAssertEqual(mockUserDefaults.gameStyleChanged, 0, "gameStyleChanged should be 0 before sendActions")
    segmentedControl.addTarget(sut, action: #selector(ViewController.chooseGameStyle(_:)), for: .valueChanged)
    segmentedControl.sendActions(for: .valueChanged)
    
    // then
    XCTAssertEqual(mockUserDefaults.gameStyleChanged, 1, "gameStyle user default wasn't changed")
}
```

assertion 타이밍은 테스트 메소드가 세그먼트 컨트롤을 변경하여 `gameStyleChanged` 플래그는 0이 될 떄이다.\
assetion은 true라면 `set(_:forKey:)`가 한번 호출될 것이다.\
테스트를 실행해보면 성공하는 것을 볼 수 있다.

&nbsp;

---

&nbsp;

## UI Testing in Xcode

UI 테스트는 유저 인터페이스의 상호작용을 테스트 할 수 있게 해준다.\
UI 테스트는 앱의 요청이 발생하는 UI 오브젝트를 해당 이벤트에 맞추 발생시키고 그 객체들에게 이벤트를 보낸다.\
그 api들은 UI 오브젝트의 속성들을 시험할 수 있게 해주고 그에 상응하는 상태를 비교할 수 있게 해준다.\
\
테스트 네비게이터에서 새 `UI Test Target`을 추가한다.\
타겟이 `BullsEye`인지 확인하고 `BullsEyeUITests`로 이름 짓는다.\
\
`BullsEyeUITests`를 열고 최상단에 아래의 변수를 추가한다.
```swift
var app: XCUIApplication!
```

`tearDownWithError()`을 제거하고 `setUpWithError()`에 아래의 내용을 추가한다.
```swift
try super.setUpWithError()
continueAfterFailure = false
app = XCUIApplication()
app.launch()
```

미리 생성되어 있던 두 함수를 제거하고 아래의 함수를 추가한다.
```swift
func testGameStyleSwitch() {    
}
```

`testGameStyleSwitch()`에 새 라인을 하나 추가하고 디버그콘솔페인에 있는 녹화 버튼을 누른다.\
이는 시뮬레이터를 녹화모드로 앱을 열게하고 인터렉션을 테스트 커맨드로 녹화한다.\
앱이 로드되면 게임 스타일 스위치에 있는 슬라이드 세그먼트와 상단 레이블을 탭하자.\
녹화 버튼을 다시 눌러 녹화를 중단하자.\
\
그렇게 하면 아래와 같은 3개의 라인이 생긴다.

```swift
let app = XCUIApplication()
app.buttons["Slide"].tap()
app.staticTexts["Get as close as you can to: "].tap()
```

레코더가 방금 녹화한 행위와 같은 행동을 취하는 코드를 작성한다.\
게임 스타일 새그먼트와 상단 레이블을 탭하는 요청을 날리게 된다.\
앞으로 UI 테스트를 작성하는데 이 방식을 사용하게 된다.\
혹시 다른 상태가 나타난다면 삭제하도록 하자.\
\
첫번째 라인은 setUpWithError()에 추가한 프로퍼티와 중복되므로 제거한다.\
아직은 어떤것도 탭을 할 필요가 없으므로 2번 3번 라인의 .tap()을 제거하자.\
이제 ["Slide"] 옆에 있는 작은 메뉴를 열고 `segmentedControls.buttons["Slide"]`를 선택하면 아래와 같은 코드가 될 것이다.\
Now, open the little menu next to ["Slide"] and select segmentedControls.buttons["Slide"].


```swift
app.segmentedControls.buttons["Slide"]
app.staticTexts["Get as close as you can to: "]
```

레코드 상태에서 다른 객체를 탭하는 것으로 테스트에서 접근가능한 객체를 찾는데 도움을 줄 것이다.\
이제 given 섹션을 만들기 위해 아래의 내용을 추가하자.

```swift
// given
let slideButton = app.segmentedControls.buttons["Slide"]
let typeButton = app.segmentedControls.buttons["Type"]
let slideLabel = app.staticTexts["Get as close as you can to: "]
let typeLabel = app.staticTexts["Guess where the slider is: "]
```

Now that you have names for the two buttons in the segmented control 
and the two possible top labels, add the following code below:
세그먼트 컨트롤에 있는 두 버튼과 상단 레이블들의 이름을 얻었으니 다음의 코드를 추가하자.

```swift
// given
let slideButton = app.segmentedControls.buttons["Slide"]
let typeButton = app.segmentedControls.buttons["Type"]
let slideLabel = app.staticTexts["Get as close as you can to: "]
let typeLabel = app.staticTexts["Guess where the slider is: "]

// then
if slideButton.isSelected {
    XCTAssertTrue(slideLabel.exists)
    XCTAssertFalse(typeLabel.exists)
    
    typeButton.tap()
    XCTAssertTrue(typeLabel.exists)
    XCTAssertFalse(slideLabel.exists)
} else if typeButton.isSelected {
    XCTAssertTrue(typeLabel.exists)
    XCTAssertFalse(slideLabel.exists)
    
    slideButton.tap()
    XCTAssertTrue(slideLabel.exists)
    XCTAssertFalse(typeLabel.exists)
}
```

이것은 세그먼트 컨틀롤러의 각 버튼을 누를 때마다 해당 레이블이 존재하는지를 체크하게 된다.\
테스트를 실행하면 모든 assertoin이 성공하는 것을 볼 수 있다.

&nbsp;

---

&nbsp;

## Testing Performance

애플의 공식 문서에 따르면 퍼포먼스 테스트는 아래와 같다.

*A performance test takes a block of code that you want to evaluate and runs it ten times, collecting the average execution time and the standard deviation for the runs. 
The averaging of these individual measurements form a value for the test run that can then be compared against a baseline to evaluate success or failure.*

퍼포먼스 테스트를 작성하는 것은 간단하다.\
측정하고 하는 곳에 measure() 클러저를 추가하자.\
추가로 몇번 측정할 것인지도 특정할 수 있다.

아래의 코드를 `BullsEyeTests`에 추가하자.
```swift
func testScoreIsComputedPerformance() {
    measure(metrics: [XCTClockMetric(),
                        XCTCPUMetric(),
                        XCTStorageMetric(),
                        XCTMemoryMetric()]) {
        sut.check(guess: 100)
    }
}
```

이 테스트는 아래의 범위를 측정한다.
* XCTClockMetric: 경과 시간
* XCTCPUMetric: CPU 사용시간을 포함한 지속적인 CPU 사용량 및 사용 회수 추적
* XCTStorageMetric: 테스트 코드가 스토리지에 어느 정도 양의 테스트 코드를 썼는지
* XCTMemoryMetric: 사용된 물리 메모리의 양 추적

테스트를 실행한 후 통계를 보기위해 measure() 클로저의 시작부분에 있는 아이콘을 클릭하자.\
선택한 측정치의 다음 측정치로 전환할 수도 있다.\
\
set baseline을 클릭하여 레퍼런스 타임을 설정하자.\
퍼포먼스 테스트를 다시 실행한 후 결과를 보면 베이스라인과 비교하여 높거나 낮은 결과를 볼 수 있다.\
에디트 버튼을 눌러 새 결과로 베이스라인을 다시 설정할수도 있다.\
\
베이스 라인은 각 디바이스 설정 단위로 저정하므로 여러 단말에서 같은 테스트를 실행할 수 있다.\
각 테스트는 특정 프로세서 속도, 메모리 등등의 설정에 따른 별개의 베이스라인에 의존하게 할 수 있다.\
\
언제든 테스트된 메소드의 퍼포먼스에 영향을 주는 앱으로 변경할 수 있다.

&nbsp;

---

&nbsp;

## Enabling Code Coverage

코드 커버리지는 어떤 코드가 실제로 테스트 되었는지 어떤 부분이 테스트 되지 않았는지를 알려준다.\
\
코드 커버리지를 활성화하기 위해 스키마의 테스트 액션을 수정하고 옵션탭 아래에 있는 체크박스를 체크하자. \
\
cmd+u를 눌러 모든 테스트를 실행하고 cmd+9를 눌러 리포트 네비게이션을 열어 리스트의 최상단에 있는 `Coverage`를 선택한다.\
\
닫혀진 삼각형 확장 버튼을 눌러 `BullsEyeGame`의 함수들과 클로저들의 리스트를 연다.\
\
스크롤을 아래로 내리면 `getRandomNumber(completion:)`에 95.0%로 나오는 것을 볼 수 있다.\
\
소스의 함수를 열기위해 이 함수의 화살표 버튼을 누른다.\
오른쪽 사이드바의 커버리지 어노테이션에 마우스를 올리면 녹색이나 빨간색으로 코드 섹션이 하이라이트 된다.\
\
커버리지 어노테이션은 각 코드섹션의 몇번 실행되었는지를 보여준다.\
호출되지 않은 섹션은 빨간색으로 하이라이트 된다.

&nbsp;

---

&nbsp;

## Where to Go From Here?
* WWDC17 video
    * [Engineering for Testability](https://developer.apple.com/videos/play/wwdc2017/414/)
    * [Testing Tips & Tricks](https://developer.apple.com/videos/play/wwdc2018/417/)
* automation(CI/CD) tutorials
    * [Continuous Integration With GitHub, Fastlane & Jenkins](https://www.raywenderlich.com/1774995-continuous-integration-with-github-fastlane-jenkins)
    * [Xcode Server for iOS: Getting Started](https://www.raywenderlich.com/12258400-xcode-server-for-ios-getting-started)
    * Apple’s [Automating the Test Process with Xcode Server and xcodebuild](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/08-automation.html#//apple_ref/doc/uid/TP40014132-CH7-SW1)
    * Wikipedia’s [continuous delivery article](https://en.wikipedia.org/wiki/Continuous_delivery), which draws on expertise from [ThoughtWorks](https://www.thoughtworks.com/continuous-delivery).
* 테스트 코드를 작성하지 않은 앱을 갖고 있다면 [Working Effectively with Legacy Code by Michael Feathers](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?s=books&ie=UTF8&qid=1481511568&sr=1-1)를 참고하자.\
이제 테스트가 없는 코드는 레거시 코드다!
* Jon Reid의 [Quality Coding sample app archive](http://qualitycoding.org/tdd-sample-archives/)는 TDD를 배우기에 더 없이 훌륭하다.
    